"use client"

import { useEffect, useRef, useState } from "react"

export default function VulnerabilityOverviewChart() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })

  useEffect(() => {
    const handleResize = () => {
      if (canvasRef.current) {
        const canvas = canvasRef.current
        // Get the display size of the canvas
        const displayWidth = canvas.clientWidth
        const displayHeight = 300

        // Set dimensions state for potential use elsewhere
        setDimensions({ width: displayWidth, height: displayHeight })

        // Set canvas dimensions with device pixel ratio for sharp rendering
        const dpr = window.devicePixelRatio || 1
        canvas.width = displayWidth * dpr
        canvas.height = displayHeight * dpr

        const ctx = canvas.getContext("2d")
        if (ctx) {
          // Scale all drawing operations by the dpr
          ctx.scale(dpr, dpr)
        }

        // Draw the chart with the new dimensions
        drawChart(displayWidth, displayHeight)
      }
    }

    // Initial setup
    handleResize()

    // Add event listener for window resize
    window.addEventListener("resize", handleResize)

    // Cleanup
    return () => {
      window.removeEventListener("resize", handleResize)
    }
  }, [])

  const drawChart = (width: number, height: number) => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    // Clear canvas
    ctx.clearRect(0, 0, width, height)

    // Mock data for the radar chart
    const categories = [
      "Tool Poisoning",
      "Parameter Injection",
      "Context Leakage",
      "Cross-Tool Manipulation",
      "Authentication",
      "Input Validation",
    ]

    const scores = [65, 78, 82, 90, 95, 72]
    const maxScore = 100

    // Calculate center and radius
    const centerX = width / 2
    const centerY = height / 2
    // Ensure radius is always positive with a minimum value
    const radius = Math.max(20, Math.min(centerX, centerY) - 60)

    // Draw background circles
    ctx.strokeStyle = "#E2E8F0"
    ctx.fillStyle = "#F8FAFC"

    // Draw filled background
    ctx.beginPath()
    for (let i = 0; i < categories.length; i++) {
      const angle = (Math.PI * 2 * i) / categories.length - Math.PI / 2
      const x = centerX + radius * Math.cos(angle)
      const y = centerY + radius * Math.sin(angle)

      if (i === 0) {
        ctx.moveTo(x, y)
      } else {
        ctx.lineTo(x, y)
      }
    }
    ctx.closePath()
    ctx.fill()
    ctx.stroke()

    // Draw concentric circles
    for (let i = 1; i <= 4; i++) {
      const circleRadius = (radius * i) / 4
      if (circleRadius <= 0) continue // Skip if radius is not positive

      ctx.beginPath()
      ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2)
      ctx.stroke()
    }

    // Draw axes
    ctx.strokeStyle = "#CBD5E1"
    for (let i = 0; i < categories.length; i++) {
      const angle = (Math.PI * 2 * i) / categories.length - Math.PI / 2
      const x = centerX + radius * Math.cos(angle)
      const y = centerY + radius * Math.sin(angle)

      ctx.beginPath()
      ctx.moveTo(centerX, centerY)
      ctx.lineTo(x, y)
      ctx.stroke()

      // Draw category labels
      ctx.fillStyle = "#64748B"
      ctx.font = "12px Ubuntu, sans-serif"
      ctx.textAlign = "center"
      ctx.textBaseline = "middle"

      const labelX = centerX + (radius + 25) * Math.cos(angle)
      const labelY = centerY + (radius + 25) * Math.sin(angle)

      ctx.fillText(categories[i], labelX, labelY)
    }

    // Draw data
    ctx.fillStyle = "rgba(17, 106, 204, 0.2)" // Primary color with opacity
    ctx.strokeStyle = "#116ACC" // Primary color
    ctx.lineWidth = 2

    ctx.beginPath()
    for (let i = 0; i < categories.length; i++) {
      const angle = (Math.PI * 2 * i) / categories.length - Math.PI / 2
      const value = scores[i] / maxScore
      const x = centerX + radius * value * Math.cos(angle)
      const y = centerY + radius * value * Math.sin(angle)

      if (i === 0) {
        ctx.moveTo(x, y)
      } else {
        ctx.lineTo(x, y)
      }

      // Draw points
      ctx.fillStyle = "#116ACC" // Primary color
      ctx.beginPath()
      ctx.arc(x, y, 4, 0, Math.PI * 2)
      ctx.fill()
    }

    ctx.fillStyle = "rgba(17, 106, 204, 0.2)" // Primary color with opacity
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
  }

  return (
    <div className="w-full h-[300px]">
      <canvas ref={canvasRef} className="w-full h-full" style={{ width: "100%", height: "300px" }} />
    </div>
  )
}
